/* **DISCLAIMER**
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
 * 1. the software will meet your requirements or expectations;
 * 2. the software or the software content will be free of bugs, errors, viruses or other defects;
 * 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
 * 4. the software will be compatible with third party software;
 * 5. any errors in the software will be corrected.
 * The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
 */ 
 
/*
 * This is the device type code for a z-wave customized thermostat with battery status, humidity, clock set, up-down tiles and icons. For individual customizations look at this thread:
 * http://community.smartthings.com/t/z-wave-customized-thermostat-with-battery-humidity-clock-set-up-down-tiles-and-icons/7284
 * Base code has been take from SmartThings as of Sept 2015
 * Version 2.2.5
 *
 * Thermostat with Temperature, Humidity and Auto Time setting
 *
 * Taken from SmartThings base code, thanks to @minollo, enhanced and bugfixed by RBoy
 * Changes Copyright RBoy, redistribution of any changes or modified code is not allowed without permission
 *
 * Change log:
 * 2016-2-10 - Improve polling handler when skipping polling
 * 2016-2-6 - Bugfix for configure throwing error
 * 2016-2-6 - Fixed refresh on configuration
 * 2016-2-2 - Add initialization on settings update
 * 2016-1-28 - Pressing Mode and Auto no longer goes into hunting mode, only one command at a time
 * 2016-1-28 - Fix for Level Up/down for Android
 * 2016-1-27 - Fix for ST iOS 2.0.8 release breaking Battery UI
 * 2016-1-24 - Updated base code to 2016-1-24 (emergency heat is now emergencyHeat)
 * 2016-1-24 - Bugfix for error on handling invalid / empty z-wave multiInstance command
 * 2016-1-2 - Temporary workaround for ? showing up on Android 2.0.7
 * 2015-12-6 - ST fixed the VALUE_CONTROL issues with the iOS release 2.0.5, reenabling it
 * 2015-10-23 - VALUE_CONTROL causes the new ST app to crash, so disabled this feature until ST fixes their crappy app
 * 2015-9-26 - Added color palette for Humidity
 * 2015-9-23 - Updated layout and colors
 * 2015-9-19 - Added support for MultiAttributeTiles
 * 2015-8-7 - Fix for polling stopping when in battery save mode
 * 2015-7-25 - Report change in state when operating state and fan state change
 * 2015-7-22 - Updated to sync with ST base code
 * 2015-7-12 - Fixed issue with battery and humidity not being reported
 * 2015-7-9 - Added support fot battery save mode to reduce polling frequency to 30 minutes
 * 2015-6-7 - Fix for Humidity not working (thanks @schettj)
 * 2015-4-24 - Fix to supporting C and F for temp up/down
 * 2015-2-10 - Added capability for battery
 * 2015-2-3 - Updated base code to 2015-2-3, support for thermostatFanState attribute and Emergency Heat, added sliders for temp to make faster changes
 * 2015-1-1 - Fix for battery update
 * 2014-11-1 - Humidity, Battery update, Auto time setting
 *
 */
 
 /**
 *  Z-Wave Thermostat
 *
 *  Copyright 2014 SmartThings
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 *
 */ 
metadata {
	// Automatically generated. Make future change here.
	definition (name: "Thermostat with Temperature, Humidity and Auto Time setting", namespace: "rboy", author: "RBoy") {
		capability "Actuator"
		capability "Temperature Measurement"
		capability "Relative Humidity Measurement"
		capability "Thermostat"
		capability "Configuration"
		capability "Polling"
		capability "Sensor"
		capability "Refresh"
        capability "Battery"

		attribute "thermostatFanState", "string"
        attribute "thermStatus", "string"

		command "switchMode"
		command "switchFanMode"
        command "quickSetCool"
        command "quickSetHeat"
		command "refresh"
		command "heatLevelUp"
		command "heatLevelDown"
		command "coolLevelUp"
		command "coolLevelDown"
        command "levelUpDown"

		fingerprint deviceId: "0x08"
		fingerprint inClusters: "0x43,0x40,0x44,0x31"
	}

	// simulator metadata
	simulator {
		status "off"			: "command: 4003, payload: 00"
		status "heat"			: "command: 4003, payload: 01"
		status "cool"			: "command: 4003, payload: 02"
		status "auto"			: "command: 4003, payload: 03"
		status "emergencyHeat"	: "command: 4003, payload: 04"

		status "fanAuto"		: "command: 4403, payload: 00"
		status "fanOn"			: "command: 4403, payload: 01"
		status "fanCirculate"	: "command: 4403, payload: 06"

		status "heat 60"        : "command: 4303, payload: 01 09 3C"
		status "heat 68"        : "command: 4303, payload: 01 09 44"
		status "heat 72"        : "command: 4303, payload: 01 09 48"

		status "cool 72"        : "command: 4303, payload: 02 09 48"
		status "cool 76"        : "command: 4303, payload: 02 09 4C"
		status "cool 80"        : "command: 4303, payload: 02 09 50"

		status "temp 58"        : "command: 3105, payload: 01 2A 02 44"
		status "temp 62"        : "command: 3105, payload: 01 2A 02 6C"
		status "temp 70"        : "command: 3105, payload: 01 2A 02 BC"
		status "temp 74"        : "command: 3105, payload: 01 2A 02 E4"
		status "temp 78"        : "command: 3105, payload: 01 2A 03 0C"
		status "temp 82"        : "command: 3105, payload: 01 2A 03 34"

		status "idle"			: "command: 4203, payload: 00"
		status "heating"		: "command: 4203, payload: 01"
		status "cooling"		: "command: 4203, payload: 02"
		status "fan only"		: "command: 4203, payload: 03"
		status "pending heat"	: "command: 4203, payload: 04"
		status "pending cool"	: "command: 4203, payload: 05"
		status "vent economizer": "command: 4203, payload: 06"

		// reply messages
		reply "2502": "command: 2503, payload: FF"
	}

    preferences {
       input "batterySaveMode", "bool", title: "Save Thermostat Battery", description: "Enable this to reduce polling frequency to once in 30 minutes to save thermostat battery", required: true, displayDuringSetup: true
    }
              
	tiles(scale: 2) {
		multiAttributeTile(name:"summary", type: "thermostat", width: 6, height: 4){
			tileAttribute ("device.temperature", key: "PRIMARY_CONTROL") {
                attributeState("temperature", label:'${currentValue}', unit:"dF",
                    backgroundColors:[
                        [value: 31, color: "#153591"],
                        [value: 44, color: "#1e9cbb"],
                        [value: 59, color: "#90d2a7"],
                        [value: 74, color: "#44b621"],
                        [value: 84, color: "#f1d801"],
                        [value: 95, color: "#d04e00"],
                        [value: 96, color: "#bc2323"]
                    ]
                )
            }
            tileAttribute ("device.thermStatus", key: "SECONDARY_CONTROL") {
				attributeState "thermStatus", label:'${currentValue}'
            }
            tileAttribute ("device.level", key: "VALUE_CONTROL") {
				attributeState "level", action: "levelUpDown"
            }
            tileAttribute("device.thermostatOperatingState", key: "OPERATING_STATE") {
                attributeState("idle", backgroundColor:"#44b621")
                attributeState("heating", backgroundColor:"#ffa81e")
                attributeState("cooling", backgroundColor:"#269bd2")
            }
            tileAttribute("device.thermostatMode", key: "THERMOSTAT_MODE") {
                attributeState("off", label:'${name}')
                attributeState("heat", label:'${name}')
                attributeState("cool", label:'${name}')
                attributeState("auto", label:'${name}')
            }
            /*tileAttribute("device.heatingSetpoint", key: "HEATING_SETPOINT") {
                attributeState("default", label:'${currentValue}', unit:"dF")
            }
            tileAttribute("device.coolingSetpoint", key: "COOLING_SETPOINT") {
                attributeState("default", label:'${currentValue}', unit:"dF")
            }*/
        }
		valueTile("temperature", "device.temperature", width: 4, height: 4) {
			state("temperature", label:'${currentValue}°',
				backgroundColors:[
					[value: 31, color: "#153591"],
					[value: 44, color: "#1e9cbb"],
					[value: 59, color: "#90d2a7"],
					[value: 74, color: "#44b621"],
					[value: 84, color: "#f1d801"],
					[value: 95, color: "#d04e00"],
					[value: 96, color: "#bc2323"]
				]
			)
		}
		standardTile("mode", "device.thermostatMode", width: 2, height: 2, inactiveLabel: false, canChangeIcon: false) {
			state "off", label:'Off', action:"switchMode", nextState:"...", icon: "st.Outdoor.outdoor19"
			state "heat", label:'Heat', action:"switchMode", nextState:"...", icon: "st.Weather.weather14", backgroundColor: '#E14902'
			state "cool", label:'Cool', action:"switchMode", nextState:"...", icon: "st.Weather.weather7", backgroundColor: '#003CEC'
			state "auto", label:'Auto', action:"switchMode", nextState:"...", icon: "st.Home.home1"
			state "emergencyHeat", label:'Emergency Heat', action:"switchMode", nextState:"...", icon: "st.Weather.weather2", backgroundColor: '#E11102'
			state "...", label: "...", nextState:"..."
		}
		standardTile("fanMode", "device.thermostatFanMode", width: 2, height: 2, inactiveLabel: false, canChangeIcon: false) {
			state "fanAuto", label:'Auto', action:"switchFanMode", nextState:"...", icon: "st.Appliances.appliances11"
			state "fanOn", label:'On', action:"switchFanMode", nextState:"...", icon: "st.Appliances.appliances11", backgroundColor: '#02E181'
			state "fanCirculate", label:'Circulate', action:"switchFanMode", nextState:"...", icon: "st.Appliances.appliances11", backgroundColor: '#02D2E1'
			state "...", label: "...", nextState:"..."
		}
		controlTile("heatSliderControl", "device.heatingSetpoint", "slider", width: 4, height: 1, inactiveLabel: false) {
			state "setHeatingSetpoint", action:"quickSetHeat", backgroundColor:"#d04e00"
		}
		valueTile("heatingSetpoint", "device.heatingSetpoint", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "heat", label:'${currentValue}°', backgroundColor: '#E14902'
		}
		controlTile("coolSliderControl", "device.coolingSetpoint", "slider", width: 4, height: 1, inactiveLabel: false) {
			state "setCoolingSetpoint", action:"quickSetCool", backgroundColor: "#1e9cbb"
		}
		valueTile("coolingSetpoint", "device.coolingSetpoint", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "cool", label:'${currentValue}°', backgroundColor: '#003CEC'
		}
        standardTile("refresh", "command.refresh", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "default", action:"refresh.refresh", icon:"st.secondary.refresh"
		}
		standardTile("configure", "device.configure", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "configure", label:'', action:"configuration.configure", icon:"st.secondary.configure"
		}
		standardTile("heatLevelUp", "device.heatLevelUp", width: 2, height: 1, inactiveLabel: false, decoration: "flat") {
            state "heatLevelUp", label:'Heat', action:"heatLevelUp", icon:"st.thermostat.thermostat-up"
		}
		standardTile("heatLevelDown", "device.heatLevelDown", width: 2, height: 1, inactiveLabel: false, decoration: "flat") {
            state "heatLevelDown", label:'Heat', action:"heatLevelDown", icon:"st.thermostat.thermostat-down"
		}
		standardTile("coolLevelUp", "device.coolLevelUp", width: 2, height: 1, inactiveLabel: false, decoration: "flat") {
            state "coolLevelUp", label:'Cool', action:"coolLevelUp", icon:"st.thermostat.thermostat-up"
		}
		standardTile("coolLevelDown", "device.coolLevelDown", width: 2, height: 1, inactiveLabel: false, decoration: "flat") {
            state "coolLevelDown", label:'Cool', action:"coolLevelDown", icon:"st.thermostat.thermostat-down"
		}
		valueTile("battery", "device.battery", width: 2, height: 2, inactiveLabel: false) {
            state "battery", label:'Battery\n ${currentValue}%', unit: "", backgroundColors:[
                [value: 15, color: "#ff0000"],
                [value: 30, color: "#fd4e3a"],
                [value: 50, color: "#fda63a"],
                [value: 60, color: "#fdeb3a"],
                [value: 75, color: "#d4fd3a"],
                [value: 90, color: "#7cfd3a"],
                [value: 99, color: "#55fd3a"]
            ]
        }
		valueTile("humidity", "device.humidity", width: 2, height: 2, inactiveLabel: false) {
            state "humidity", label:'\n\n  ${currentValue}%', icon:"st.Weather.weather12", backgroundColors: [
                [value: 20, color: "#ffe700"],
                [value: 30, color: "#d6ff00"],
                [value: 45, color: "#3cff00"],
                [value: 60, color: "#00ffb8"],
                [value: 80, color: "#00dfff"]
            ]
        }
		
        main "summary"
			details(["summary", "mode", "fanMode", "humidity", "heatingSetpoint", "heatLevelDown", "heatLevelUp", "heatSliderControl", "coolingSetpoint", "coolLevelDown", "coolLevelUp", "coolSliderControl", "refresh", "battery", "configure"])
	}
}

def updated() {
	log.trace "Update called settings: $settings"
	try {
		if (!state.init) {
			state.init = true
		}
        refresh() // Get the updates
	} catch (e) {
		log.warn "updated() threw $e"
	}
}

def parse(String description)
{
	def map = createEvent(zwaveEvent(zwave.parse(description, [0x42:1, 0x43:2, 0x31: 3])))
	if (!map) {
		return null
	}

	def result = [map]
	if (map.isStateChange && map.name in ["heatingSetpoint","coolingSetpoint","thermostatMode"]) {
		def map2 = [
			name: "thermostatSetpoint",
			unit: getTemperatureScale()
		]
		if (map.name == "thermostatMode") {
			state.lastTriedMode = map.value
			if (map.value == "cool") {
				map2.value = device.latestValue("coolingSetpoint")
				log.info "THERMOSTAT, latest cooling setpoint = ${map2.value}"
			}
			else {
				map2.value = device.latestValue("heatingSetpoint")
				log.info "THERMOSTAT, latest heating setpoint = ${map2.value}"
			}
		}
		else {
			def mode = device.latestValue("thermostatMode")
			log.info "THERMOSTAT, latest mode = ${mode}"
			if ((map.name == "heatingSetpoint" && mode == "heat") || (map.name == "coolingSetpoint" && mode == "cool")) {
				map2.value = map.value
				map2.unit = map.unit
			}
		}
		if (map2.value != null) {
			log.debug "THERMOSTAT, adding setpoint event: $map"
			result << createEvent(map2)
		}
	} else if (map.name == "thermostatFanMode" && map.isStateChange) {
		state.lastTriedFanMode = map.value
	}

    def thermStatusS = "System ${device.currentState('thermostatOperatingState')?.value} | Fan ${device.currentState('thermostatFanState')?.value} | Battery ${device.currentState('battery')?.value}%"
    sendEvent("name": "thermStatus", "value": thermStatusS, displayed: false, isStateChange: true)
    log.trace thermStatusS
    
	log.debug "Parse returned $result"
	result
}

// Event Generation
def zwaveEvent(physicalgraph.zwave.commands.thermostatsetpointv2.ThermostatSetpointReport cmd)
{
	def cmdScale = cmd.scale == 1 ? "F" : "C"
	def map = [:]
	map.value = convertTemperatureIfNeeded(cmd.scaledValue, cmdScale, cmd.precision)
	map.unit = getTemperatureScale()
	map.displayed = true
	switch (cmd.setpointType) {
		case 1:
			map.name = "heatingSetpoint"
			break;
		case 2:
			map.name = "coolingSetpoint"
			break;
		default:
			return [:]
	}
	// So we can respond with same format
	state.size = cmd.size
	state.scale = cmd.scale
	state.precision = cmd.precision
	map
}

def zwaveEvent(physicalgraph.zwave.commands.sensormultilevelv3.SensorMultilevelReport cmd)
{
	def map = [:]
	map.displayed = true
    map.isStateChange = true
	if (cmd.sensorType == 1) {
		map.value = convertTemperatureIfNeeded(cmd.scaledSensorValue, cmd.scale == 1 ? "F" : "C", cmd.precision)
		map.unit = getTemperatureScale()
		map.name = "temperature"
	} else if (cmd.sensorType == 5) {
		map.value = cmd.scaledSensorValue
		map.unit = "%"
		map.name = "humidity"
	}
	map
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport cmd)
{
	def map = [:]
	switch (cmd.operatingState) {
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_IDLE:
			map.value = "idle"
			break
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_HEATING:
			map.value = "heating"
			break
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_COOLING:
			map.value = "cooling"
			break
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_FAN_ONLY:
			map.value = "fan only"
			break
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_PENDING_HEAT:
			map.value = "pending heat"
			break
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_PENDING_COOL:
			map.value = "pending cool"
			break
		case physicalgraph.zwave.commands.thermostatoperatingstatev1.ThermostatOperatingStateReport.OPERATING_STATE_VENT_ECONOMIZER:
			map.value = "vent economizer"
			break
	}
	map.name = "thermostatOperatingState"
	map.displayed = true
    map.isStateChange = true
	map
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatfanstatev1.ThermostatFanStateReport cmd) {
	def map = [name: "thermostatFanState"]
	switch (cmd.fanOperatingState) {
		case 0:
			map.value = "idle"
			break
		case 1:
			map.value = "running"
			break
		case 2:
			map.value = "running high"
			break
	}
	map.displayed = true
    map.isStateChange = true
	map
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport cmd) {
	def map = [:]
	switch (cmd.mode) {
		case physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport.MODE_OFF:
			map.value = "off"
			break
		case physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport.MODE_HEAT:
			map.value = "heat"
			break
		case physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport.MODE_AUXILIARY_HEAT:
			map.value = "emergencyHeat"
			break
		case physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport.MODE_COOL:
			map.value = "cool"
			break
		case physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeReport.MODE_AUTO:
			map.value = "auto"
			break
	}
	map.name = "thermostatMode"
	map.displayed = true
	map
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatfanmodev3.ThermostatFanModeReport cmd) {
	def map = [:]
	switch (cmd.fanMode) {
		case physicalgraph.zwave.commands.thermostatfanmodev3.ThermostatFanModeReport.FAN_MODE_AUTO_LOW:
			map.value = "fanAuto"
			break
		case physicalgraph.zwave.commands.thermostatfanmodev3.ThermostatFanModeReport.FAN_MODE_LOW:
			map.value = "fanOn"
			break
		case physicalgraph.zwave.commands.thermostatfanmodev3.ThermostatFanModeReport.FAN_MODE_CIRCULATION:
			map.value = "fanCirculate"
			break
	}
	map.name = "thermostatFanMode"
	map.displayed = true
	map
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatmodev2.ThermostatModeSupportedReport cmd) {
	log.trace "ThermostatModeSupportedReport: $cmd"
    
	def supportedModes = ""
	if(cmd.off) { supportedModes += "off " }
	if(cmd.heat) { supportedModes += "heat " }
	if(cmd.auxiliaryemergencyHeat) { supportedModes += "emergencyHeat " }
	if(cmd.cool) { supportedModes += "cool " }
	if(cmd.auto) { supportedModes += "auto " }

	log.trace "SuppportedModes: $supportedModes"
    
	state.supportedModes = supportedModes
    null // return null as there's nothing to process
}

def zwaveEvent(physicalgraph.zwave.commands.thermostatfanmodev3.ThermostatFanModeSupportedReport cmd) {
	log.trace "ThermostatFanModeSupportedReport: $cmd"
    
	def supportedFanModes = ""
	if(cmd.auto) { supportedFanModes += "fanAuto " }
	if(cmd.low) { supportedFanModes += "fanOn " }
	if(cmd.circulation) { supportedFanModes += "fanCirculate " }

	log.trace "SuppportedFanModes: $supportedFanModes"
    
	state.supportedFanModes = supportedFanModes
    null // return null as there's nothing to process
}

def zwaveEvent(physicalgraph.zwave.commands.basicv1.BasicReport cmd) {
	log.debug "Zwave event received: $cmd"
}

def zwaveEvent(physicalgraph.zwave.Command cmd) {
	log.warn "Unexpected zwave command $cmd"
}

// Command Implementations
def poll() {
	def doPoll = false
    
    if (batterySaveMode) { // If we are in battery power save mode then we poll once it 30 minutes only
    	log.debug "Battery save mode, fetching updates every 30 minutes"
    	def nowTime = new Date().time
        def ageInMinutes = state.lastPollGet ? (nowTime - state.lastPollGet)/60000 : 30
        log.debug "Last poll ${ageInMinutes} minutes ago"
        if (ageInMinutes >= 30) {
		    state.lastPollGet = nowTime
            log.info "Fetching fresh thermostate state"
            doPoll = true
        }
	} else {
    	doPoll = true // no battery save, lets get the values
    }
    
    if (doPoll) {
    	log.trace "Polling thermostat information"
        delayBetween([
            zwave.sensorMultilevelV3.sensorMultilevelGet().format(), // current temperature
            zwave.thermostatSetpointV1.thermostatSetpointGet(setpointType: 1).format(),
            zwave.thermostatSetpointV1.thermostatSetpointGet(setpointType: 2).format(),
            zwave.thermostatModeV2.thermostatModeGet().format(),
            zwave.thermostatFanModeV3.thermostatFanModeGet().format(),
            zwave.thermostatOperatingStateV1.thermostatOperatingStateGet().format(),
            getBattery(),
            setClock(),
            zwave.multiInstanceV1.multiInstanceCmdEncap(instance: 2).encapsulate(zwave.sensorMultilevelV3.sensorMultilevelGet()).format() // CT-100/101 Customization - Humidity is an encapsulated multilevel sensor get command, 2nd instance
        ], 2300)
    }
    else {
        log.trace "Poll called again to soon, skipping poll to save battery"
    	sendEvent(name: "battery", value: device.currentValue("battery"), unit: "%", descriptionText: "Battery save mode", displayed: false, isStateChange: true) // We need to send something otherwise Poll dies if nothing is done
		device.activity()  // workaround to keep polling from being shut off
        null
    }
}

def quickSetHeat(degrees) {
	setHeatingSetpoint(degrees, 1000)
}

def setHeatingSetpoint(degrees, delay = 30000) {
	setHeatingSetpoint(degrees.toDouble(), delay)
}

def setHeatingSetpoint(Double degrees, Integer delay = 30000) {
	log.trace "setHeatingSetpoint($degrees, $delay)"
	def deviceScale = state.scale ?: 1
	def deviceScaleString = deviceScale == 2 ? "C" : "F"
    def locationScale = getTemperatureScale()
	def p = (state.precision == null) ? 1 : state.precision

    def convertedDegrees
    if (locationScale == "C" && deviceScaleString == "F") {
    	convertedDegrees = celsiusToFahrenheit(degrees)
    } else if (locationScale == "F" && deviceScaleString == "C") {
    	convertedDegrees = fahrenheitToCelsius(degrees)
    } else {
    	convertedDegrees = degrees
    }

	delayBetween([
		zwave.thermostatSetpointV1.thermostatSetpointSet(setpointType: 1, scale: deviceScale, precision: p, scaledValue: convertedDegrees).format(),
		zwave.thermostatSetpointV1.thermostatSetpointGet(setpointType: 1).format()
	], delay)
}

def quickSetCool(degrees) {
	setCoolingSetpoint(degrees, 1000)
}

def setCoolingSetpoint(degrees, delay = 30000) {
	setCoolingSetpoint(degrees.toDouble(), delay)
}

def setCoolingSetpoint(Double degrees, Integer delay = 30000) {
    log.trace "setCoolingSetpoint($degrees, $delay)"
	def deviceScale = state.scale ?: 1
	def deviceScaleString = deviceScale == 2 ? "C" : "F"
    def locationScale = getTemperatureScale()
	def p = (state.precision == null) ? 1 : state.precision

    def convertedDegrees
    if (locationScale == "C" && deviceScaleString == "F") {
    	convertedDegrees = celsiusToFahrenheit(degrees)
    } else if (locationScale == "F" && deviceScaleString == "C") {
    	convertedDegrees = fahrenheitToCelsius(degrees)
    } else {
    	convertedDegrees = degrees
    }

	delayBetween([
		zwave.thermostatSetpointV1.thermostatSetpointSet(setpointType: 2, scale: deviceScale, precision: p,  scaledValue: convertedDegrees).format(),
		zwave.thermostatSetpointV1.thermostatSetpointGet(setpointType: 2).format()
	], delay)
}

def configure() {
	log.debug "Configure called"
    
	delayBetween([
		zwave.thermostatModeV2.thermostatModeSupportedGet().format(),
		zwave.thermostatFanModeV3.thermostatFanModeSupportedGet().format(),
		zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:[zwaveHubNodeId]).format()
	], 2300)
}

def modes() {
	["off", "heat", "cool", "auto", "emergencyHeat"]
}

def switchMode() {
	def currentMode = device.currentState("thermostatMode")?.value
	def lastTriedMode = state.lastTriedMode ?: currentMode ?: "off"
	def supportedModes = getDataByName("supportedModes")
	def modeOrder = modes()
	def next = { modeOrder[modeOrder.indexOf(it) + 1] ?: modeOrder[0] }
	def nextMode = next(lastTriedMode)
	if (supportedModes?.contains(currentMode)) {
		while (!supportedModes.contains(nextMode) && nextMode != "off") {
			nextMode = next(nextMode)
		}
	}
	state.lastTriedMode = nextMode
	delayBetween([
		zwave.thermostatModeV2.thermostatModeSet(mode: modeMap[nextMode]).format(),
		zwave.thermostatModeV2.thermostatModeGet().format()
	], 1000)
}

def switchToMode(nextMode) {
	def supportedModes = getDataByName("supportedModes")
	if(supportedModes && !supportedModes.contains(nextMode)) log.warn "thermostat mode '$nextMode' is not supported"
	if (nextMode in modes()) {
		state.lastTriedMode = nextMode
		"$nextMode"()
	} else {
		log.debug("no mode method '$nextMode'")
	}
}

def switchFanMode() {
	def currentMode = device.currentState("thermostatFanMode")?.value
	def lastTriedMode = state.lastTriedFanMode ?: currentMode ?: "off"
	def supportedModes = getDataByName("supportedFanModes") ?: "fanAuto fanOn"
	def modeOrder = ["fanAuto", "fanCirculate", "fanOn"]
	def next = { modeOrder[modeOrder.indexOf(it) + 1] ?: modeOrder[0] }
	def nextMode = next(lastTriedMode)
	while (!supportedModes?.contains(nextMode) && nextMode != "fanAuto") {
		nextMode = next(nextMode)
	}
	switchToFanMode(nextMode)
}

def switchToFanMode(nextMode) {
	def supportedFanModes = getDataByName("supportedFanModes")
	if(supportedFanModes && !supportedFanModes.contains(nextMode)) log.warn "thermostat mode '$nextMode' is not supported"

	def returnCommand
	if (nextMode == "fanAuto") {
		returnCommand = fanAuto()
	} else if (nextMode == "fanOn") {
		returnCommand = fanOn()
	} else if (nextMode == "fanCirculate") {
		returnCommand = fanCirculate()
	} else {
		log.debug("no fan mode '$nextMode'")
	}
	if(returnCommand) state.lastTriedFanMode = nextMode
	returnCommand
}

def getDataByName(String name) {
	state[name] ?: device.getDataValue(name)
}

def getModeMap() { [
	"off": 0,
	"heat": 1,
	"cool": 2,
	"auto": 3,
	"emergencyHeat": 4
]}

def setThermostatMode(String value) {
	delayBetween([
		zwave.thermostatModeV2.thermostatModeSet(mode: modeMap[value]).format(),
		zwave.thermostatModeV2.thermostatModeGet().format()
	], standardDelay)
}

def getFanModeMap() { [
	"auto": 0,
	"on": 1,
	"circulate": 6
]}

def setThermostatFanMode(String value) {
	delayBetween([
		zwave.thermostatFanModeV3.thermostatFanModeSet(fanMode: fanModeMap[value]).format(),
		zwave.thermostatFanModeV3.thermostatFanModeGet().format()
	], standardDelay)
}

def off() {
	delayBetween([
		zwave.thermostatModeV2.thermostatModeSet(mode: 0).format(),
		zwave.thermostatModeV2.thermostatModeGet().format()
	], standardDelay)
}

def heat() {
	delayBetween([
		zwave.thermostatModeV2.thermostatModeSet(mode: 1).format(),
		zwave.thermostatModeV2.thermostatModeGet().format()
	], standardDelay)
}

def emergencyHeat() {
	delayBetween([
		zwave.thermostatModeV2.thermostatModeSet(mode: 4).format(),
		zwave.thermostatModeV2.thermostatModeGet().format()
	], standardDelay)
}

def cool() {
	delayBetween([
		zwave.thermostatModeV2.thermostatModeSet(mode: 2).format(),
		zwave.thermostatModeV2.thermostatModeGet().format()
	], standardDelay)
}

def auto() {
	delayBetween([
		zwave.thermostatModeV2.thermostatModeSet(mode: 3).format(),
		zwave.thermostatModeV2.thermostatModeGet().format()
	], standardDelay)
}

def fanOn() {
	delayBetween([
		zwave.thermostatFanModeV3.thermostatFanModeSet(fanMode: 1).format(),
		zwave.thermostatFanModeV3.thermostatFanModeGet().format()
	], standardDelay)
}

def fanAuto() {
	delayBetween([
		zwave.thermostatFanModeV3.thermostatFanModeSet(fanMode: 0).format(),
		zwave.thermostatFanModeV3.thermostatFanModeGet().format()
	], standardDelay)
}

def fanCirculate() {
	delayBetween([
		zwave.thermostatFanModeV3.thermostatFanModeSet(fanMode: 6).format(),
		zwave.thermostatFanModeV3.thermostatFanModeGet().format()
	], standardDelay)
}

private getStandardDelay() {
	1000
}

def zwaveEvent(physicalgraph.zwave.commands.multichannelv3.MultiInstanceCmdEncap cmd) {
    def encapsulatedCommand = cmd?.encapsulatedCommand([0x31: 3]) // Encapsulate Sensor Multi Level (0x31) and use Version 3 of the class
    log.debug ("multichannelv3.MultiInstanceCmdEncap: command from instance ${cmd?.instance}: ${encapsulatedCommand}")
    if (encapsulatedCommand) {
        return zwaveEvent(encapsulatedCommand)
    } else {
    	log.warn "multichannelv3.MultiInstanceCmdEncap: unrecognized command $cmd"
    }
}

def zwaveEvent(physicalgraph.zwave.commands.batteryv1.BatteryReport cmd) {
    def map = [ name: "battery", unit: "%" ]
    map.isStateChange = true
    map.displayed = true
    log.debug "Battery level $cmd.batteryLevel%"
    if (cmd.batteryLevel == 0xFF || cmd.batteryLevel == 0) {
        map.value = 1
        map.descriptionText = "battery is low!"
    } else {
        map.value = cmd.batteryLevel
    }
    map
}

private getBattery() {	//once every 24 hours
	def nowTime = new Date().time
	def ageInMinutes = state.lastBatteryGet ? (nowTime - state.lastBatteryGet)/60000 : 1440
    log.debug "Battery report age: ${ageInMinutes} minutes"
    if (ageInMinutes >= 1440) {
	    state.lastBatteryGet = nowTime
        log.debug "Fetching fresh battery value"
		zwave.batteryV1.batteryGet().format()
    } else "delay 87"
}

private setClock() {	// once a day
	def nowTime = new Date().time
	def ageInMinutes = state.lastClockSet ? (nowTime - state.lastClockSet)/60000 : 1440
    log.debug "Clock set age: ${ageInMinutes} minutes"
    if (ageInMinutes >= 1440) {
		state.lastClockSet = nowTime
        def nowCal = Calendar.getInstance(location.timeZone) // get current location timezone
		log.debug "Setting clock to ${nowCal.getTime().format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}"
		sendEvent(name: "SetClock", value: "setting clock to ${nowCal.getTime().format("EEE MMM dd yyyy HH:mm:ss z", location.timeZone)}", displayed: true)
		zwave.clockV1.clockSet(hour: nowCal.get(Calendar.HOUR_OF_DAY), minute: nowCal.get(Calendar.MINUTE), weekday: nowCal.get(Calendar.DAY_OF_WEEK)).format()
    } else "delay 87"
}

def refresh() {
    // Force a refresh
    log.info "Requested a refresh"
    state.lastBatteryGet = (new Date().time) - (1440 * 60000)
    state.lastClockSet = (new Date().time) - (1440 * 60000)
    state.lastPollGet = (new Date().time) - (30 * 60000)
    poll()
}

def coolLevelUp() {
    def locationScale = getTemperatureScale()
    def maxTemp
    def minTemp
    if (locationScale == "C") {
    	maxTemp = 37 // Max Temp in C
        minTemp = 1 // Min Temp in C
    	log.trace "Location is in Celsius, MaxTemp $maxTemp, MinTemp $minTemp"
    } else {
    	maxTemp = 99 // Max temp in F
    	minTemp = 35 // Max temp in F
    	log.trace "Location is in Farenheit, MaxTemp $maxTemp, MinTemp $minTemp"
    }

    int nextLevel = device.currentValue("coolingSetpoint") + 1
    
    if( nextLevel > maxTemp) {
    	nextLevel = maxTemp
    }
    log.debug "Setting cool set point up to: ${nextLevel}"
    quickSetCool(nextLevel)
}

def coolLevelDown() {
    def locationScale = getTemperatureScale()
    def maxTemp
    def minTemp
    if (locationScale == "C") {
    	maxTemp = 37 // Max Temp in C
        minTemp = 1 // Min Temp in C
    	log.trace "Location is in Celsius, MaxTemp $maxTemp, MinTemp $minTemp"
    } else {
    	maxTemp = 99 // Max temp in F
    	minTemp = 35 // Max temp in F
    	log.trace "Location is in Farenheit, MaxTemp $maxTemp, MinTemp $minTemp"
    }

	int nextLevel = device.currentValue("coolingSetpoint") - 1
    
    if( nextLevel < minTemp) {
    	nextLevel = minTemp
    }
    log.debug "Setting cool set point down to: ${nextLevel}"
    quickSetCool(nextLevel)
}

def heatLevelUp() {
    def locationScale = getTemperatureScale()
    def maxTemp
    def minTemp
    if (locationScale == "C") {
    	maxTemp = 37 // Max Temp in C
        minTemp = 1 // Min Temp in C
    	log.trace "Location is in Celsius, MaxTemp $maxTemp, MinTemp $minTemp"
    } else {
    	maxTemp = 99 // Max temp in F
    	minTemp = 35 // Max temp in F
    	log.trace "Location is in Farenheit, MaxTemp $maxTemp, MinTemp $minTemp"
    }

    int nextLevel = device.currentValue("heatingSetpoint") + 1
    
    if( nextLevel > maxTemp) {
    	nextLevel = maxTemp
    }
    log.debug "Setting heat set point up to: ${nextLevel}"
    quickSetHeat(nextLevel)
}

def heatLevelDown() {
    def locationScale = getTemperatureScale()
    def maxTemp
    def minTemp
    if (locationScale == "C") {
    	maxTemp = 37 // Max Temp in C
        minTemp = 1 // Min Temp in C
    	log.trace "Location is in Celsius, MaxTemp $maxTemp, MinTemp $minTemp"
    } else {
    	maxTemp = 99 // Max temp in F
    	minTemp = 35 // Max temp in F
    	log.trace "Location is in Farenheit, MaxTemp $maxTemp, MinTemp $minTemp"
    }

    int nextLevel = device.currentValue("heatingSetpoint") - 1
    
    if( nextLevel < minTemp) {
    	nextLevel = minTemp
    }
    log.debug "Setting heat set point down to: ${nextLevel}"
    quickSetHeat(nextLevel)
}

def levelUpDown(value) {
	log.trace "levelUpDown called with value $value, current thermostat mode ${device.currentState("thermostatMode")?.value}"
    
    // NOTE: Bug in ST platform, for iOS devices we only get 0 (down) and 1 (up) for this control
    // For Android devices we get an absolute number showing the number of times up/down have been called since the page was opened (e.g. called up 4 times we get +4, if down then we get +3). If you open the page again and press up you get +1, if you close and open again and press down you get -1 (and the as long as the page is open it will be cumulative)
    
    // Determine which OS based on value behaviors (urrgghhh.....ST!)
    def upLevel
    if (!state.lastLevelUpDown)
        state.lastLevelUpDown = 0 // If it isn't defined lets baseline it

    if ((state.lastLevelUpDown == 1) && (value == 1)) // Last time it was 1 and again it's 1 its increase
    	upLevel = true
    else if ((state.lastLevelUpDown == 0) && (value == 0)) // Last time it was 0 and again it's 0 then it's decrease
    	upLevel = false
    else if ((state.lastLevelUpDown == -1) && (value == -1)) // Last time it was -1 and again it's -1 then it's decrease
    	upLevel = false
    else if ((value - state.lastLevelUpDown) > 0) // If it's increasing then it's up
    	upLevel = true
    else if ((value - state.lastLevelUpDown) < 0) // If it's decreasing then it's down
    	upLevel = false
    else
        log.error "UNDEFINED STATE, CONTACT DEVELOPER. Last level $state.lastLevelUpDown, Current level, $value"
    
    state.lastLevelUpDown = value // Save it

    if (upLevel) { // Increase the current temperature (check heating or cooling mode)
    	log.debug "Increasing temperature by 1°"
    	if (device.currentState("thermostatMode")?.value.contains("auto")) { // Auto we dont' know current mode, so change heat and cool
			delayBetween([heatLevelUp(), coolLevelUp()], 5000)
        } else if (device.currentState("thermostatMode")?.value.contains("heat")) {
        	heatLevelUp()
        } else if (device.currentState("thermostatMode")?.value.contains("cool")) {
        	coolLevelUp()
        }
    } else {
    	log.debug "Reducing temperature by 1°"
    	if (device.currentState("thermostatMode")?.value.contains("auto")) { // Auto we dont' know current mode, so change heat and cool
        	delayBetween([heatLevelDown(), coolLevelDown()], 5000)
        } else if (device.currentState("thermostatMode")?.value.contains("heat")) {
        	heatLevelDown()
        } else if (device.currentState("thermostatMode")?.value.contains("cool")) {
        	coolLevelDown()
        }
    }
    
    // NOTHING AFTER THE COMMANDS OR THE COMMANDS WONT WORK
}